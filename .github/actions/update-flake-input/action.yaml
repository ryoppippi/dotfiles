name: 'Update Flake Input'
description: 'Update a single Nix flake input with optional release age check and auto-merge'

inputs:
  input-name:
    description: 'Name of the flake input to update'
    required: true
  current-version:
    description: 'Current version/revision of the input'
    required: true
  owner:
    description: 'GitHub owner of the input repository'
    required: false
    default: ''
  repo:
    description: 'GitHub repository name of the input'
    required: false
    default: ''
  ref:
    description: 'Git ref (branch/tag) of the input'
    required: false
    default: ''
  skip-delay:
    description: 'Skip the minimum release age check'
    required: false
    default: 'false'
  minimum-release-age-days:
    description: 'Minimum release age in days before updating (default: 3)'
    required: false
    default: '3'
  auto-merge:
    description: 'Enable auto-merge for the PR'
    required: false
    default: 'true'
  pr-labels:
    description: 'Comma-separated labels to add to the PR'
    required: false
    default: 'dependencies,automated'
  github-token:
    description: 'GitHub token for creating PRs and enabling auto-merge'
    required: true

outputs:
  updated:
    description: 'Whether the input was updated'
    value: ${{ steps.update.outputs.updated }}
  new-version:
    description: 'New version/revision after update'
    value: ${{ steps.update.outputs.new_version }}
  pr-url:
    description: 'URL of the created/updated PR'
    value: ${{ steps.create-pr.outputs.pr_url }}

runs:
  using: 'composite'
  steps:
    - name: Update flake input
      id: update
      shell: bash
      env:
        INPUT_NAME: ${{ inputs.input-name }}
        INPUT_OWNER: ${{ inputs.owner }}
        INPUT_REPO: ${{ inputs.repo }}
        INPUT_REF: ${{ inputs.ref }}
        SKIP_DELAY: ${{ inputs.skip-delay }}
        MIN_AGE_DAYS: ${{ inputs.minimum-release-age-days }}
        GH_TOKEN: ${{ inputs.github-token }}
      run: |
        set -euo pipefail

        echo "=== Updating input: $INPUT_NAME ==="
        echo "Skip delay: $SKIP_DELAY"
        echo "Minimum release age: $MIN_AGE_DAYS days"

        # Calculate minimum age in seconds
        min_age_seconds=$((MIN_AGE_DAYS * 86400))

        # Get current revision before update
        current_metadata=$(nix flake metadata --json --no-write-lock-file 2>/dev/null)
        current_rev=$(echo "$current_metadata" | jq -r ".locks.nodes.\"$INPUT_NAME\".locked.rev // \"unknown\"")
        current_owner=$(echo "$current_metadata" | jq -r ".locks.nodes.\"$INPUT_NAME\".locked.owner // \"unknown\"")
        current_repo=$(echo "$current_metadata" | jq -r ".locks.nodes.\"$INPUT_NAME\".locked.repo // \"unknown\"")
        echo "Current revision: $current_rev"

        # Function to get closure diff using nix store diff-closures
        # Works for any flake input (nixpkgs, ai-tools, claude-code-overlay, etc.)
        # Output is formatted as markdown table
        get_closure_diff() {
          local input_name="$1"
          local old_ref="$2"
          local new_ref="$3"

          echo "Building Home Manager closures for comparison..." >&2

          # Build old closure
          echo "Building old closure..." >&2
          old_closure=$(nix build --no-link --print-out-paths \
            --override-input "$input_name" "$old_ref" \
            ".#homeConfigurations.ryoppippi.activationPackage" 2>/dev/null) || {
            echo "Warning: Failed to build old closure" >&2
            return
          }

          # Build new closure
          echo "Building new closure..." >&2
          new_closure=$(nix build --no-link --print-out-paths \
            --override-input "$input_name" "$new_ref" \
            ".#homeConfigurations.ryoppippi.activationPackage" 2>/dev/null) || {
            echo "Warning: Failed to build new closure" >&2
            return
          }

          if [ -n "$old_closure" ] && [ -n "$new_closure" ]; then
            echo "Comparing closures..." >&2
            # Get raw diff output
            raw_diff=$(nix store diff-closures "$old_closure" "$new_closure" 2>/dev/null) || true

            if [ -n "$raw_diff" ]; then
              # Convert to markdown table
              # Input format: "package-name: old-version → new-version, +X.X KiB"
              # or "package-name: ε → new-version, +X.X KiB" for new packages
              # or "package-name: old-version → ε, -X.X KiB" for removed packages
              echo "| Package | Old | New |"
              echo "|---------|-----|-----|"
              echo "$raw_diff" | while IFS= read -r line; do
                # Skip empty lines
                [ -z "$line" ] && continue

                # Parse the line: "package-name: old → new, size"
                if [[ "$line" =~ ^([^:]+):\ ([^→]+)\ →\ ([^,]+),\ (.+)$ ]]; then
                  pkg="${BASH_REMATCH[1]}"
                  old_ver="${BASH_REMATCH[2]}"
                  new_ver="${BASH_REMATCH[3]}"

                  # Clean up whitespace
                  pkg=$(echo "$pkg" | xargs)
                  old_ver=$(echo "$old_ver" | xargs)
                  new_ver=$(echo "$new_ver" | xargs)

                  # Replace ε with descriptive text
                  [ "$old_ver" = "ε" ] && old_ver="(new)"
                  [ "$new_ver" = "ε" ] && new_ver="(removed)"

                  # Add arrow_up emoji if version changed (not new/removed)
                  if [ "$old_ver" != "(new)" ] && [ "$new_ver" != "(removed)" ]; then
                    echo "| \`$pkg\` | \`$old_ver\` | \`$new_ver\` :arrow_up: |"
                  else
                    echo "| \`$pkg\` | \`$old_ver\` | \`$new_ver\` |"
                  fi
                fi
              done
            fi
          fi
        }

        # Determine target revision for update
        target_rev=""
        if [ "$SKIP_DELAY" = "false" ] && [ -n "$INPUT_OWNER" ] && [ -n "$INPUT_REPO" ]; then
          echo "Fetching commit from at least $MIN_AGE_DAYS days ago via GitHub API..."

          # Calculate the cutoff date
          cutoff_date=$(date -u -d "$MIN_AGE_DAYS days ago" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || \
                        date -u -v-${MIN_AGE_DAYS}d +%Y-%m-%dT%H:%M:%SZ)
          echo "Cutoff date: $cutoff_date"

          # Build the API URL with optional branch filter
          api_url="repos/${INPUT_OWNER}/${INPUT_REPO}/commits?until=${cutoff_date}&per_page=1"
          if [ -n "$INPUT_REF" ]; then
            api_url="${api_url}&sha=${INPUT_REF}"
            echo "Filtering by branch: $INPUT_REF"
          fi

          # Fetch the most recent commit that is at least MIN_AGE_DAYS old
          if commit_data=$(gh api "$api_url" --jq '.[0] | {sha: .sha, date: .commit.committer.date}' 2>/dev/null); then
            target_rev=$(echo "$commit_data" | jq -r '.sha // empty')
            commit_date=$(echo "$commit_data" | jq -r '.date // empty')

            if [ -n "$target_rev" ]; then
              echo "Found commit from $commit_date: ${target_rev:0:8}"

              # Check if this is the same as current revision
              if [ "${target_rev:0:40}" = "${current_rev:0:40}" ]; then
                echo "Target revision is the same as current. No update needed."
                echo "updated=false" >> "$GITHUB_OUTPUT"
                exit 0
              fi
            else
              echo "No commits found older than $MIN_AGE_DAYS days. Skipping update."
              echo "updated=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          else
            echo "Warning: Failed to fetch commits via GitHub API, falling back to standard update"
          fi
        fi

        # Perform the update
        if [ -n "$target_rev" ]; then
          # Update to specific revision
          echo "Running: nix flake update $INPUT_NAME --override-input $INPUT_NAME github:${INPUT_OWNER}/${INPUT_REPO}/${target_rev}"
          if ! nix flake update "$INPUT_NAME" --override-input "$INPUT_NAME" "github:${INPUT_OWNER}/${INPUT_REPO}/${target_rev}"; then
            echo "::error::Failed to update $INPUT_NAME to specific revision"
            exit 1
          fi
        else
          # Standard update (latest)
          echo "Running: nix flake update $INPUT_NAME"
          if ! nix flake update "$INPUT_NAME"; then
            echo "::error::Failed to update $INPUT_NAME"
            exit 1
          fi
        fi

        # Check if there were actual changes
        if git diff --quiet flake.lock; then
          echo "No changes detected for $INPUT_NAME"
          echo "updated=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        # Get new revision info
        new_metadata=$(nix flake metadata --json --no-write-lock-file 2>/dev/null)
        new_rev=$(echo "$new_metadata" | jq -r ".locks.nodes.\"$INPUT_NAME\".locked.rev // \"unknown\"")
        new_owner=$(echo "$new_metadata" | jq -r ".locks.nodes.\"$INPUT_NAME\".locked.owner // \"unknown\"")
        new_repo=$(echo "$new_metadata" | jq -r ".locks.nodes.\"$INPUT_NAME\".locked.repo // \"unknown\"")
        echo "New revision: $new_rev"

        # Verify release age for standard updates (when target_rev was not pre-determined)
        if [ -z "$target_rev" ] && [ "$SKIP_DELAY" = "false" ]; then
          echo "Verifying release age (minimum: $MIN_AGE_DAYS days)..."

          last_modified=$(echo "$new_metadata" | jq -r ".locks.nodes.\"$INPUT_NAME\".locked.lastModified // 0")

          if [ "$last_modified" != "0" ] && [ "$last_modified" != "null" ]; then
            current_time=$(date +%s)
            age_seconds=$((current_time - last_modified))
            age_days=$((age_seconds / 86400))

            echo "Release age: $age_days days ($age_seconds seconds)"

            if [ "$age_seconds" -lt "$min_age_seconds" ]; then
              echo "Release is too new (less than $MIN_AGE_DAYS days old). Skipping update."
              git checkout flake.lock
              echo "updated=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            echo "Release age check passed (>= $MIN_AGE_DAYS days old)"
          else
            echo "Warning: Could not determine lastModified timestamp, proceeding with update"
          fi
        else
          if [ -n "$target_rev" ]; then
            echo "Update to pre-validated revision (>= $MIN_AGE_DAYS days old)"
          else
            echo "Skipping release age check (skip_delay=true)"
          fi
        fi

        # Generate package diff using closure comparison for all inputs
        echo ""
        echo "=== Generating package diff ==="
        closure_diff=$(get_closure_diff "$INPUT_NAME" "github:${current_owner}/${current_repo}/${current_rev}" "github:${new_owner}/${new_repo}/${new_rev}") || true

        if [ -n "$closure_diff" ]; then
          echo "Package diff generated successfully"
          echo "$closure_diff"
          # Output to GitHub Step Summary
          {
            echo "## ${INPUT_NAME} Package Changes"
            echo ""
            echo "$closure_diff"
          } >> "$GITHUB_STEP_SUMMARY"
        fi

        echo "Update successful!"
        echo "updated=true" >> "$GITHUB_OUTPUT"
        echo "new_version=${new_rev:0:8}" >> "$GITHUB_OUTPUT"
        # Store closure diff (truncated for output)
        if [ -n "$closure_diff" ]; then
          # Truncate to avoid GitHub output limits
          echo "closure_diff<<EOF" >> "$GITHUB_OUTPUT"
          echo "$closure_diff" | head -100 >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
        fi

    - name: Create pull request
      id: create-pr
      if: steps.update.outputs.updated == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        INPUT_NAME: ${{ inputs.input-name }}
        CURRENT_VERSION: ${{ inputs.current-version }}
        NEW_VERSION: ${{ steps.update.outputs.new_version }}
        SKIP_DELAY: ${{ inputs.skip-delay }}
        AUTO_MERGE: ${{ inputs.auto-merge }}
        PR_LABELS: ${{ inputs.pr-labels }}
        MIN_AGE_DAYS: ${{ inputs.minimum-release-age-days }}
        CLOSURE_DIFF: ${{ steps.update.outputs.closure_diff }}
      run: |
        set -euo pipefail

        branch="update-flake-${INPUT_NAME}"

        # Build PR title
        pr_title="chore(nix): update flake input ${INPUT_NAME} to ${NEW_VERSION}"

        # Create PR body
        if [ "$SKIP_DELAY" = "true" ]; then
          delay_note=":zap: This input is configured to skip the release age check."
        else
          delay_note=":hourglass: This update passed the ${MIN_AGE_DAYS}-day minimum release age check."
        fi

        # Build package versions section if closure diff is available
        pkg_versions_section=""
        if [ -n "$CLOSURE_DIFF" ]; then
          pkg_versions_section="
        ## Package Versions

        <details>
        <summary>Click to expand package changes</summary>

        ${CLOSURE_DIFF}

        </details>"
        fi

        pr_body="Automated update of flake input \`${INPUT_NAME}\`.

        ## Changes
        - **${INPUT_NAME}**: \`${CURRENT_VERSION}\` :arrow_right: \`${NEW_VERSION}\`
        ${pkg_versions_section}

        ## Notes
        ${delay_note}

        ---
        This PR was automatically created by the flake update workflow."

        # Stage changes
        git add flake.lock

        # Create branch
        git checkout -b "$branch"

        # Build commit message
        commit_title="chore(nix): update flake input ${INPUT_NAME} to ${NEW_VERSION}"

        # Build commit body with package diff if available
        commit_body=""
        if [ -n "$CLOSURE_DIFF" ]; then
          commit_body="Package changes:

        ${CLOSURE_DIFF}"
        fi

        # Create commit with title and optional body
        if [ -n "$commit_body" ]; then
          git commit -m "$commit_title" -m "$commit_body"
        else
          git commit -m "$commit_title"
        fi

        # Push (force to handle re-runs)
        git push --force origin "$branch"

        # Check if PR exists
        pr_number=$(gh pr list --head "$branch" --json number --jq '.[0].number // empty')

        if [ -n "$pr_number" ]; then
          echo "Updating existing PR #$pr_number"
          gh pr edit "$pr_number" --title "$pr_title" --body "$pr_body"
        else
          echo "Creating new PR"

          # Build label arguments
          label_args=""
          IFS=',' read -ra labels <<< "$PR_LABELS"
          for label in "${labels[@]}"; do
            label=$(echo "$label" | xargs)
            label_args="$label_args --label $label"
          done

          gh pr create \
            --title "$pr_title" \
            --body "$pr_body" \
            --base main \
            --head "$branch" \
            $label_args

          pr_number=$(gh pr list --head "$branch" --json number --jq '.[0].number')
        fi

        # Enable auto-merge if requested
        if [ "$AUTO_MERGE" = "true" ] && [ -n "$pr_number" ]; then
          echo "Enabling auto-merge for PR #$pr_number"
          gh pr merge "$pr_number" --auto --squash || echo "Note: Auto-merge may require branch protection rules"
        fi

        pr_url=$(gh pr view "$pr_number" --json url --jq '.url')
        echo "pr_url=$pr_url" >> "$GITHUB_OUTPUT"
        echo "PR URL: $pr_url"
