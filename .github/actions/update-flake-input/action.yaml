name: 'Update Flake Input'
description: 'Update a single Nix flake input with optional release age check and auto-merge'

inputs:
  input-name:
    description: 'Name of the flake input to update'
    required: true
  current-version:
    description: 'Current version/revision of the input'
    required: true
  owner:
    description: 'GitHub owner of the input repository'
    required: false
    default: ''
  repo:
    description: 'GitHub repository name of the input'
    required: false
    default: ''
  ref:
    description: 'Git ref (branch/tag) of the input'
    required: false
    default: ''
  skip-delay:
    description: 'Skip the minimum release age check'
    required: false
    default: 'false'
  minimum-release-age-days:
    description: 'Minimum release age in days before updating (default: 3)'
    required: false
    default: '3'
  auto-merge:
    description: 'Enable auto-merge for the PR'
    required: false
    default: 'true'
  pr-labels:
    description: 'Comma-separated labels to add to the PR'
    required: false
    default: 'dependencies,automated'
  github-token:
    description: 'GitHub token for creating PRs and enabling auto-merge'
    required: true

outputs:
  updated:
    description: 'Whether the input was updated'
    value: ${{ steps.update.outputs.updated }}
  new-version:
    description: 'New version/revision after update'
    value: ${{ steps.update.outputs.new_version }}
  pr-url:
    description: 'URL of the created/updated PR'
    value: ${{ steps.create-pr.outputs.pr_url }}

runs:
  using: 'composite'
  steps:
    - name: Update flake input
      id: update
      shell: bash
      env:
        INPUT_NAME: ${{ inputs.input-name }}
        INPUT_OWNER: ${{ inputs.owner }}
        INPUT_REPO: ${{ inputs.repo }}
        INPUT_REF: ${{ inputs.ref }}
        SKIP_DELAY: ${{ inputs.skip-delay }}
        MIN_AGE_DAYS: ${{ inputs.minimum-release-age-days }}
        GH_TOKEN: ${{ inputs.github-token }}
      run: |
        set -euo pipefail

        echo "=== Updating input: $INPUT_NAME ==="
        echo "Skip delay: $SKIP_DELAY"
        echo "Minimum release age: $MIN_AGE_DAYS days"

        # Calculate minimum age in seconds
        min_age_seconds=$((MIN_AGE_DAYS * 86400))

        # Get current revision before update
        current_metadata=$(nix flake metadata --json --no-write-lock-file 2>/dev/null)
        current_rev=$(echo "$current_metadata" | jq -r ".locks.nodes.\"$INPUT_NAME\".locked.rev // \"unknown\"")
        current_owner=$(echo "$current_metadata" | jq -r ".locks.nodes.\"$INPUT_NAME\".locked.owner // \"unknown\"")
        current_repo=$(echo "$current_metadata" | jq -r ".locks.nodes.\"$INPUT_NAME\".locked.repo // \"unknown\"")
        echo "Current revision: $current_rev"

        # Function to get package versions from a flake
        get_package_versions() {
          local flake_ref="$1"
          local packages=""

          # Define packages to check for each input
          case "$INPUT_NAME" in
            llm-agents)
              packages="claude-code codex amp cursor-agent gemini-cli opencode goose-cli"
              ;;
            *)
              echo ""
              return
              ;;
          esac

          local versions=""
          for pkg in $packages; do
            local version
            version=$(nix eval --raw "${flake_ref}#packages.x86_64-linux.${pkg}.version" 2>/dev/null || echo "")
            if [ -n "$version" ]; then
              if [ -n "$versions" ]; then
                versions="${versions}, ${pkg}=${version}"
              else
                versions="${pkg}=${version}"
              fi
            fi
          done
          echo "$versions"
        }

        # Get current package versions for special inputs
        current_pkg_versions=""
        if [ "$INPUT_NAME" = "llm-agents" ]; then
          echo "Fetching current package versions..."
          current_pkg_versions=$(get_package_versions "github:${current_owner}/${current_repo}/${current_rev}")
          echo "Current package versions: $current_pkg_versions"
        fi

        # Determine target revision for update
        target_rev=""
        if [ "$SKIP_DELAY" = "false" ] && [ -n "$INPUT_OWNER" ] && [ -n "$INPUT_REPO" ]; then
          echo "Fetching commit from at least $MIN_AGE_DAYS days ago via GitHub API..."

          # Calculate the cutoff date
          cutoff_date=$(date -u -d "$MIN_AGE_DAYS days ago" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || \
                        date -u -v-${MIN_AGE_DAYS}d +%Y-%m-%dT%H:%M:%SZ)
          echo "Cutoff date: $cutoff_date"

          # Build the API URL with optional branch filter
          api_url="repos/${INPUT_OWNER}/${INPUT_REPO}/commits?until=${cutoff_date}&per_page=1"
          if [ -n "$INPUT_REF" ]; then
            api_url="${api_url}&sha=${INPUT_REF}"
            echo "Filtering by branch: $INPUT_REF"
          fi

          # Fetch the most recent commit that is at least MIN_AGE_DAYS old
          if commit_data=$(gh api "$api_url" --jq '.[0] | {sha: .sha, date: .commit.committer.date}' 2>/dev/null); then
            target_rev=$(echo "$commit_data" | jq -r '.sha // empty')
            commit_date=$(echo "$commit_data" | jq -r '.date // empty')

            if [ -n "$target_rev" ]; then
              echo "Found commit from $commit_date: ${target_rev:0:8}"

              # Check if this is the same as current revision
              if [ "${target_rev:0:40}" = "${current_rev:0:40}" ]; then
                echo "Target revision is the same as current. No update needed."
                echo "updated=false" >> "$GITHUB_OUTPUT"
                exit 0
              fi

              # Check if target is older than current (would be a downgrade)
              if [ -n "$current_rev" ] && [ "$current_rev" != "unknown" ]; then
                current_commit_date=$(gh api "repos/${INPUT_OWNER}/${INPUT_REPO}/commits/${current_rev}" --jq '.commit.committer.date' 2>/dev/null || echo "")
                if [ -n "$current_commit_date" ] && [ -n "$commit_date" ]; then
                  current_ts=$(date -d "$current_commit_date" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$current_commit_date" +%s 2>/dev/null || echo "0")
                  target_ts=$(date -d "$commit_date" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$commit_date" +%s 2>/dev/null || echo "0")
                  if [ "$target_ts" -lt "$current_ts" ]; then
                    echo "Target revision (${target_rev:0:8} from $commit_date) is older than current (${current_rev:0:8} from $current_commit_date). Skipping to avoid downgrade."
                    echo "updated=false" >> "$GITHUB_OUTPUT"
                    exit 0
                  fi
                fi
              fi
            else
              echo "No commits found older than $MIN_AGE_DAYS days. Skipping update."
              echo "updated=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          else
            echo "Warning: Failed to fetch commits via GitHub API, falling back to standard update"
          fi
        fi

        # Perform the update
        if [ -n "$target_rev" ]; then
          # Update to specific revision
          echo "Running: nix flake update $INPUT_NAME --override-input $INPUT_NAME github:${INPUT_OWNER}/${INPUT_REPO}/${target_rev}"
          if ! nix flake update "$INPUT_NAME" --override-input "$INPUT_NAME" "github:${INPUT_OWNER}/${INPUT_REPO}/${target_rev}"; then
            echo "::error::Failed to update $INPUT_NAME to specific revision"
            exit 1
          fi
        else
          # Standard update (latest)
          echo "Running: nix flake update $INPUT_NAME"
          if ! nix flake update "$INPUT_NAME"; then
            echo "::error::Failed to update $INPUT_NAME"
            exit 1
          fi
        fi

        # Check if there were actual changes
        if git diff --quiet flake.lock; then
          echo "No changes detected for $INPUT_NAME"
          echo "updated=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        # Get new revision info
        new_metadata=$(nix flake metadata --json --no-write-lock-file 2>/dev/null)
        new_rev=$(echo "$new_metadata" | jq -r ".locks.nodes.\"$INPUT_NAME\".locked.rev // \"unknown\"")
        new_owner=$(echo "$new_metadata" | jq -r ".locks.nodes.\"$INPUT_NAME\".locked.owner // \"unknown\"")
        new_repo=$(echo "$new_metadata" | jq -r ".locks.nodes.\"$INPUT_NAME\".locked.repo // \"unknown\"")
        echo "New revision: $new_rev"

        # Get new package versions for special inputs
        new_pkg_versions=""
        pkg_version_diff=""
        if [ "$INPUT_NAME" = "llm-agents" ]; then
          echo "Fetching new package versions..."
          new_pkg_versions=$(get_package_versions "github:${new_owner}/${new_repo}/${new_rev}")
          echo "New package versions: $new_pkg_versions"

          # Build version diff for changed packages
          if [ -n "$current_pkg_versions" ] && [ -n "$new_pkg_versions" ]; then
            # Parse and compare versions
            declare -A old_versions new_versions
            IFS=', ' read -ra old_pairs <<< "$current_pkg_versions"
            for pair in "${old_pairs[@]}"; do
              key="${pair%%=*}"
              val="${pair#*=}"
              old_versions["$key"]="$val"
            done
            IFS=', ' read -ra new_pairs <<< "$new_pkg_versions"
            for pair in "${new_pairs[@]}"; do
              key="${pair%%=*}"
              val="${pair#*=}"
              new_versions["$key"]="$val"
            done

            # Find changed versions
            changed_pkgs=""
            for key in "${!new_versions[@]}"; do
              old_val="${old_versions[$key]:-}"
              new_val="${new_versions[$key]}"
              if [ "$old_val" != "$new_val" ] && [ -n "$old_val" ]; then
                if [ -n "$changed_pkgs" ]; then
                  changed_pkgs="${changed_pkgs}, ${key} ${old_val} → ${new_val}"
                else
                  changed_pkgs="${key} ${old_val} → ${new_val}"
                fi
              fi
            done

            if [ -n "$changed_pkgs" ]; then
              pkg_version_diff="$changed_pkgs"
              echo "Package version changes: $pkg_version_diff"
            fi
          fi
        fi

        # Verify release age for standard updates (when target_rev was not pre-determined)
        if [ -z "$target_rev" ] && [ "$SKIP_DELAY" = "false" ]; then
          echo "Verifying release age (minimum: $MIN_AGE_DAYS days)..."

          last_modified=$(echo "$new_metadata" | jq -r ".locks.nodes.\"$INPUT_NAME\".locked.lastModified // 0")

          if [ "$last_modified" != "0" ] && [ "$last_modified" != "null" ]; then
            current_time=$(date +%s)
            age_seconds=$((current_time - last_modified))
            age_days=$((age_seconds / 86400))

            echo "Release age: $age_days days ($age_seconds seconds)"

            if [ "$age_seconds" -lt "$min_age_seconds" ]; then
              echo "Release is too new (less than $MIN_AGE_DAYS days old). Skipping update."
              git checkout flake.lock
              echo "updated=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            echo "Release age check passed (>= $MIN_AGE_DAYS days old)"
          else
            echo "Warning: Could not determine lastModified timestamp, proceeding with update"
          fi
        else
          if [ -n "$target_rev" ]; then
            echo "Update to pre-validated revision (>= $MIN_AGE_DAYS days old)"
          else
            echo "Skipping release age check (skip_delay=true)"
          fi
        fi

        echo "Update successful!"
        echo "updated=true" >> "$GITHUB_OUTPUT"
        echo "new_version=${new_rev:0:8}" >> "$GITHUB_OUTPUT"
        echo "current_pkg_versions=${current_pkg_versions}" >> "$GITHUB_OUTPUT"
        echo "new_pkg_versions=${new_pkg_versions}" >> "$GITHUB_OUTPUT"
        echo "pkg_version_diff=${pkg_version_diff}" >> "$GITHUB_OUTPUT"

    - name: Create pull request
      id: create-pr
      if: steps.update.outputs.updated == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        INPUT_NAME: ${{ inputs.input-name }}
        CURRENT_VERSION: ${{ inputs.current-version }}
        NEW_VERSION: ${{ steps.update.outputs.new_version }}
        SKIP_DELAY: ${{ inputs.skip-delay }}
        AUTO_MERGE: ${{ inputs.auto-merge }}
        PR_LABELS: ${{ inputs.pr-labels }}
        MIN_AGE_DAYS: ${{ inputs.minimum-release-age-days }}
        CURRENT_PKG_VERSIONS: ${{ steps.update.outputs.current_pkg_versions }}
        NEW_PKG_VERSIONS: ${{ steps.update.outputs.new_pkg_versions }}
        PKG_VERSION_DIFF: ${{ steps.update.outputs.pkg_version_diff }}
      run: |
        set -euo pipefail

        branch="update-flake-${INPUT_NAME}"

        # Build PR title with package version diff if available
        if [ -n "$PKG_VERSION_DIFF" ]; then
          pr_title="chore(nix): update ${INPUT_NAME} (${PKG_VERSION_DIFF})"
        else
          pr_title="chore(nix): update flake input ${INPUT_NAME} to ${NEW_VERSION}"
        fi

        # Create PR body
        if [ "$SKIP_DELAY" = "true" ]; then
          delay_note=":zap: This input is configured to skip the release age check."
        else
          delay_note=":hourglass: This update passed the ${MIN_AGE_DAYS}-day minimum release age check."
        fi

        # Build package versions section if available
        pkg_versions_section=""
        if [ -n "$NEW_PKG_VERSIONS" ]; then
          pkg_versions_section="
        ## Package Versions
        | Package | Old | New |
        |---------|-----|-----|"

          # Parse current and new versions into arrays
          declare -A old_versions new_versions
          if [ -n "$CURRENT_PKG_VERSIONS" ]; then
            IFS=', ' read -ra old_pairs <<< "$CURRENT_PKG_VERSIONS"
            for pair in "${old_pairs[@]}"; do
              key="${pair%%=*}"
              val="${pair#*=}"
              old_versions["$key"]="$val"
            done
          fi
          IFS=', ' read -ra new_pairs <<< "$NEW_PKG_VERSIONS"
          for pair in "${new_pairs[@]}"; do
            key="${pair%%=*}"
            val="${pair#*=}"
            new_versions["$key"]="$val"
          done

          # Build table rows
          for key in "${!new_versions[@]}"; do
            old_val="${old_versions[$key]:-N/A}"
            new_val="${new_versions[$key]}"
            if [ "$old_val" != "$new_val" ]; then
              pkg_versions_section="${pkg_versions_section}
        | ${key} | \`${old_val}\` | \`${new_val}\` :arrow_up: |"
            else
              pkg_versions_section="${pkg_versions_section}
        | ${key} | \`${old_val}\` | \`${new_val}\` |"
            fi
          done
        fi

        pr_body="Automated update of flake input \`${INPUT_NAME}\`.

        ## Changes
        - **${INPUT_NAME}**: \`${CURRENT_VERSION}\` :arrow_right: \`${NEW_VERSION}\`
        ${pkg_versions_section}

        ## Notes
        ${delay_note}

        ---
        This PR was automatically created by the flake update workflow."

        # Stage changes
        git add flake.lock

        # Create branch
        git checkout -b "$branch"

        # Build commit message with package version diff if available
        if [ -n "$PKG_VERSION_DIFF" ]; then
          commit_message="chore(nix): update ${INPUT_NAME} (${PKG_VERSION_DIFF})"
        else
          commit_message="chore(nix): update flake input ${INPUT_NAME} to ${NEW_VERSION}"
        fi

        git commit -m "$commit_message"

        # Push (force to handle re-runs)
        git push --force origin "$branch"

        # Check if PR exists
        pr_number=$(gh pr list --head "$branch" --json number --jq '.[0].number // empty')

        if [ -n "$pr_number" ]; then
          echo "Updating existing PR #$pr_number"
          gh pr edit "$pr_number" --title "$pr_title" --body "$pr_body"
        else
          echo "Creating new PR"

          # Build label arguments
          label_args=""
          IFS=',' read -ra labels <<< "$PR_LABELS"
          for label in "${labels[@]}"; do
            label=$(echo "$label" | xargs)
            label_args="$label_args --label $label"
          done

          gh pr create \
            --title "$pr_title" \
            --body "$pr_body" \
            --base main \
            --head "$branch" \
            $label_args

          pr_number=$(gh pr list --head "$branch" --json number --jq '.[0].number')
        fi

        # Enable auto-merge if requested
        if [ "$AUTO_MERGE" = "true" ] && [ -n "$pr_number" ]; then
          echo "Enabling auto-merge for PR #$pr_number"
          gh pr merge "$pr_number" --auto --squash || echo "Note: Auto-merge may require branch protection rules"
        fi

        pr_url=$(gh pr view "$pr_number" --json url --jq '.url')
        echo "pr_url=$pr_url" >> "$GITHUB_OUTPUT"
        echo "PR URL: $pr_url"
